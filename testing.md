## Уровни тестирования

#### Модульное тестирование (Unit testing)

Модульное тестирование применяется для исследования каждого отдельного элемента или объекта системы изолированно. Чтобы
найти баги, применяя
модульное тестирование, нужно знать, как устроена программа в целом и какой функционал каждого отдельного модуля. Этот
уровень программирования
используется больше программистами, нежели тестировщиками. Они создают специальные тест-коды, с помощью которых можно
проверить, выполняет ли
программное обеспечение свое предназначение.

#### Интеграционное тестирование (Integration testing)

Если модульное тестирование - это проверка каждого отдельного модуля, то во время интеграционного тестирования
программист проверяет, как отдельные
модули взаимодействуют вместе, то есть интегрируясь друг с другом. Интеграционное тестирование наиболее подходит для
поиска багов в разработке
интерфейса системы. И чаще всего в этом уровне тестирования используют подход "сверху вниз", когда систему проверяют по
архитектурному строению.

#### Системное тестирование (System testing)

Здесь проверяется вся система целостно на наличие в ней багов. В системном тестировании тестировщик проверяет
взаимосвязь между всеми аппаратными
и программными компонентами системы и потом тестирует уже методику работы всей системы.

#### Приемочное тестирование (Acceptance testing)

Этот уровень тестирования используют уже почти перед непосредственной передачей программного обеспечения заказчику. Его
используют, чтобы проверить
соответствует ли разработанный продукт тем требованиям, которые выдвигал заказчик. Приемочное тестирование может
осуществляться командой
разработчиков, его еще называют внутренние тестирование. Второй вариант или внешнее приемочное тестирование, когда
программное обеспечение тестирует
сам заказчик.

---

## Testcontainers

**Testcontainers** — это библиотека тестирования, которая позволяет писать тесты с использованием реальных зависимостей
с
помощью одноразовых
контейнеров Docker. Она предоставляет программируемый API для создания необходимых зависимых сервисов в виде контейнеров
Docker, чтобы вы могли
писать тесты, используя реальные сервисы вместо макетов. Таким образом, независимо от того, пишете ли вы модульные
тесты, тесты API или сквозные
тесты, вы можете писать тесты с использованием реальных зависимостей с помощью одной и той же модели программирования.

---

## TDD

**TDD, test-driven development или процесс разработки через тестирование** — это методология разработки программного
обеспечения, которая основывается
на повторении коротких циклов разработки: изначально пишется тест, покрывающий желаемое изменение, затем пишется
программный код,
который реализует желаемое поведение системы и позволит пройти написанный тест, а затем проводится рефакторинг
написанного кода с постоянной
проверкой прохождения всех тестов.

#### Цикл разработки по TDD

- Добавить тест для новой (еще не реализованной) функциональности или для воспроизведения существующего бага
- Запустить все тесты и убедиться, что новый тест не проходит
- Написать код, который обеспечит прохождение теста:
- Запустить тесты и убедиться, что они все прошли успешно: прохождение нового теста подтверждает реализацию нового
  функционала или исправление
  существующей ошибки, а прохождение остальных позволяет удостовериться, что ранее реализованный функционал работает
  по‑прежнему корректно.
- Заняться рефакторингом и оптимизацией — улучшение сопровождаемости и быстродействия целесообразно осуществлять уже
  после того,
  как получилось добиться проверяемой работоспособности
- Перезапустить тесты и убедиться, что они все ещё проходят успешно
- Повторить цикл

---

## Test doubles

**Test doubles** - это объекты, которые выглядят и ведут себя, как их настоящие эквиваленты, но которые на самом деле
сильно упрощены.
Они уменьшают сложность, позволяют проверять код независимо от остальной части системы, и иногда даже необходимо
выполнять самоподтверждающие
тесты вообще.

#### Типы test doubles:

- Fake
- Stub
- Mock
- Spy
- Dummy object

**Fake (имитация)** - это объекты, имеющие рабочие реализации, но не такие, как у настоящих рабочих объектов. Обычно они
идут коротким путем и имеют
упрощенную версию реального объекта. Можно, например, сделать фейковый класс для подключения к БД.

**Stub (заглушка)** - объект, содержащий предопределённые данные и использует их для ответа на вызовы во время тестов.
Она
используется,
когда мы не можем или не хотим привлекать объекты, которые бы отвечали реальными данными или имели бы нежелательные
побочные эффекты.
В качестве примера может быть объект, который должен получить некоторые данные из базы данных в качестве результата при
вызове метода.
Вместо реального объекта, мы вводим заглушку и определяем в ней, какие данные она должна вернуть.

Методы, возвращающие некоторый результат и не изменяющие состояние системы, называют **Query (запрос)**.
Существует также другая категория методов — **Command (команда)**. Это когда метод выполняет некоторые действия, которые
изменяют состояние системы,
но мы не ожидаем от него никакого возвращаемого значения.

> Если при тестировании выполняется запрос, тогда лучше использовать заглушку, если выполняется команда - тогда
> подставной объект.

**Mock (подставной объект)** - это объекты, которые регистрируют получаемые вызовы. В тестовом утверждении мы можем
проверить, используя подставной
объект, что все ожидаемые действия (вызовы) были выполнены.

Мы используем подставной объект, когда не хотим вовлекать реально работающий код или когда нет простого способа
проверки, что код действительно
был выполнен. Нет возвращаемого значения, а значит нет лёгкого пути проверить изменение состояния системы. В качестве
примера может послужить
функциональность, вызывающая сервис отправки электронной почты. Мы не хотим отправлять электронные письма каждый раз,
когда запускаем тест.
Кроме того, в тестах нелегко проверить, что письмо на самом деле было отправлено. Единственно, что мы можем сделать —
это проверить результаты
функциональности, которые выполняется в нашем тесте. Другими словами — убедиться, что был вызван сервис отправки
электронной почты.

**Spy (шпион)** - объект, который используется для наблюдения, записывая вызовы методов. На этапе проверки результатов тест
сравнивает фактические
значения, переданные в шпиона, со значениями ожидаемыми тестом.

Можно использовать как дополнительную опцию для тестирования: проверить какие-нибудь side-эффекты, что выдают сторонние
методы.

**Dummy object (фиктивный объект)** - это объект, который передается в метод, но на самом деле не используется, не
производит никаких изменений,
не вызывает другие методы и не имеет никакого поведения.
Такой объект нужен просто для того, чтобы тест прошел. Очень часто это просто NULL или пустой объект. 