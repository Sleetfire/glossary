## Как обеспечить консистентность данных между 2 БД?

1. Двухфазные транзакции, если говорить строго, спецификация XA+, позволяющая создавать транзакции, распределенные
   относительно приложений — весьма тяжеловесный механизм, который мало кто любит и, что более важно, мало кто умеет
   настраивать.
2. Для решения задачи можно использовать многочисленные системы распределенного консенсуса (грубо говоря, все, что
   гуглится по ключевым словам paxos, raft, zookeeper, etcd, consul).

---

## Как обеспечить доставку данных между двумя сервисами (iMessage broker)?

* Синхронный протокол. Один из примеров — HTTP. Клиент отправляет запрос сервису и ожидает ответа. Важной особенностью
  протокола (HTTP/HTTPS) является синхронность. Дальнейшее исполнение клиентского кода возможно только после получения
  ответа от сервера HTTP.
* Асинхронный протокол. Пример — AMQP (поддерживается многими операционными системами и облачными средами). Код клиента
  или отправитель сообщения обычно не ожидают ответа. Они просто отправляют сообщение в сервис передачи сообщений, такой
  как RabbitMQ или Kafka (если используется управляемая событиями архитектура).

---

## Если нужно читать параллельно из Kafka, как будут читаться сообщения?

Проблему чтения можно представить следующим образом:

* Топик имеет несколько партиций.
* Использовать топик может одновременно множество групп консюмеров.
* Группа консюмеров может иметь несколько отдельных экземпляров.

> Консюмер запрашивает (polls) сообщения из топика, что приводит к их последовательному чтению из журнала.
> Позиция смещения регулярно коммитится обратно в Kafka и сохраняется, как сообщения во внутреннем топике _
> consumer_offsets. Прочитанные сообщения все равно не удаляются, в отличие от обычного брокера, и клиент может
> перемотать (rewind) смещение, чтобы повторно обработать уже просмотренные сообщения.
> Когда подключается второй логический консюмер, используя другой group_id, он управляет вторым указателем, который не
> зависит от первого. Таким образом, топик Kafka действует как очередь, в которой существует один консюмер и, как
> обычный
> топик издатель-подписчик (pub-sub), на который подписаны несколько консюмеров, с дополнительным преимуществом, что все
> сообщения сохраняются и могут обрабатываться несколько раз.

![img.png](pictures/img.png)

---

## Что использовать Kafka или HTTP для взаимодействия между сервисами?

Все зависит от задачи. HTTP применяется для синхронного взаимодействия, например, получить какие-нибудь данные по id
пользователя. Kafka применяется же при асинхронном взаимодействии, для снижения нагрузки.

---

## Сервис начал тормозить. Что делать (вопрос про GET метод)?

1. При запросе можно указывать список полей, которые хотим получить, чтобы уменьшить тело ответа.
2. Запрашивать данные не по отдельности, а сразу несколько (список).
3. Использовать фильтрацию и пагинацию.
4. Использовать batch запросы.

---

## Какие плюсы и минусы Hibernate

#### Плюсы:

* **Популярность.** По фреймворку много статей, обсуждений и уроков, на любой вопрос найдётся ответ.
* **Поддержка других инструментов.** Большинство библиотек и фреймворков Java работают с Hibernate без нареканий и
  сложных интеграций.
* **Облегчение кода.** С фреймворком программисту не нужно постоянно писать десятки одинаковых строк кода — программа
  становится понятнее, лаконичнее и легче.
* **Освобождение от рутины.** Разработчику не нужно писать огромное число запросов и «скучного» рутинного кода. Этим
  займётся Hibernate, и можно будет сосредоточиться на действительно сложных задачах, требующих творческого подхода.
* **Независимость от баз данных.** Не важно, какая БД используется в текущем проекте, — через Hibernate разработчику
  легко будет с ней работать.

#### Минусы:

* **Сложность в освоении.** Чтобы правильно писать код с Hibernate, нужно понимать принципы работы баз данных и знать
  синтаксис библиотеки. Этому придётся учиться.
* **Низкая производительность при использовании сложных моделей данных.** Несмотря на «ленивую загрузку», код,
  написанный с помощью Hibernate, обычно чуть медленнее и тяжелее чистого.
* **Непредсказуемость.** Из-за особенностей спецификации JPA значения в коде иногда могут изменяться, когда разработчики
  этого не задумывали. Такие моменты важно подмечать во время тестирования.
* **Неполное кэширование.** Кэш помогает улучшить производительность, однако в Hibernate нельзя кэшировать изменяемые
  функции. Это накладывает на разработчиков некоторые ограничения.

---

## В чем проблема N+1 и как ее решать?

> Проблема N + 1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL-запросов для получения тех
> же данных, которые можно получить при выполнении одного SQL-запроса.

Эта проблема часто возникает при работе с отношениями между сущностями один-ко-многим, один-к-одному, при жадной и
ленивой загрузках.

Проблему можно решить, используя join fetch в HQL. Но у этого метода есть недостатки. Например, использование
методов `setMaxResults()` и `setFirstResult()`.

Также можно попробовать избавиться от проблемы, используя аннотацию
`@LazyToOne(LazyToOneOption.NO_PROXY)` для OneToOne или ManyToOne связи.

* `LazyToOneOption.NO_PROXY` - означает, что будет загружен реальный объект, а не прокси.
* `LazyToOneOption.FALSE` - жадная загрузка.
* `LazyToOneOption.PROXY` - означает, что будет загружен прокси-объект.

1. Избегать двухстороннего @OneToOne.
2. Везде использовать FetchType.Lazy.
3. Не использовать @BatchSize и @Fetch.
4. Использовать query fetch в HQL, Criteria API, QuerydsL. Но fetch нет в getById.
5. Использовать EntityGraph API, а не @FetchProfile.

---

## LazyInitializationException

Сменить FetchType на EAGER: @OneToMany(fetch = FetchType.EAGER)

Использовать загрузка коллекции открытым сеансом в представлении (транзакция в представлении).

> Open Session in View (или Transaction in View) — это шаблон проектирования, в котором соединение с базой данных будет
> оставаться открытым до конца пользовательского запроса. Когда приложение обращается к отложенной коллекции,
> Hibernate /
> JPA выполнит запрос к базе данных без проблем, исключений не будет.

Но при использовании этого подхода может возникнуть N+1 проблема.

---

## Open Session in View

> Open Session in View (или Transaction in View) — это шаблон проектирования, в котором соединение с базой данных будет
> оставаться открытым до конца пользовательского запроса. Когда приложение обращается к отложенной коллекции,
> Hibernate /
> JPA выполнит запрос к базе данных без проблем, исключений не будет.

Но при использовании этого подхода может возникнуть N+1 проблема.

---

## Какие уровни блокировок Optimistic/Pessimistic

**Оптимистичные блокировки** предполагают, что множество транзакций могут завершиться без влияния друг на друга, и таким
образом могут выполняться без блокировок тех ресурсов, на которые они влияют. Перед коммитом, каждая транзакция
проверяет, что ни одна другая транзакция не модифицировала ее данные. Если проверка выявила конфликтующие модификации,
транзакция, находящаяся в состоянии коммита, откатывается.

**Пессимистичная стратегия** подразумевает, что параллельные транзакции будут конфликтовать каждая друг с другом, и
требует
блокировки ресурсов после их чтения, а также ее снятия только после того, как приложение завершило использование данных.
Hibernate предоставляет механизмы для реализации обеих стратегий блокировок в вашем приложении.

---

## Способы внедрения Bean

1. Через конструктор.
2. Через поле + @Autowired.
3. Через сеттер + @Autowired.
4. Через фабричный метод.

---

## Что будет при циклической зависимости. Как разрешить?

Циклическая зависимость возникает, когда бин А зависит от бина Б, а бин Б - от А. Тогда при инициализации будет
выброшено исключение `BeanCurrentlyInCreationException`.

Решение:

1. Пересмотр архитектуры. Мне нравится использовать паттерн `декоратор` для решения циклических зависимостей.
2. Использовать аннотацию `@Lazy` в одном из конструкторов бина.
3. Внедрять зависимость через сеттер.
4. Использовать аннотацию `@PostConstruct`, чтобы в init-методе внедрить зависимость.
5. Реализовать интерфейсы `ApplicationContextAware` и `InitializingBean` (зачем его, если есть @PostConstruct).
   ApplicationContextAware позволяет засетать ApplicationContext, откуда можно будет достать нужный нам бин. А интерфейс
   InitializingBean заставляет нас переопределить метод для инициализации бина, где можно будет сделать инжект.

---

## Для чего нужны профили в Spring?

Профили Spring позволяют кастомизировать приложение для работы в различном окружении. В зависимости от активного профиля
можно инстанциировать различные реализации одного и того же бина, а также присваивать различные значения свойствам
приложения.

---

## Для чего нужна аннотация @ConditionalOnProperty?

Данная аннотация нужна, чтобы сообщить конфигурации или компоненту, что бины/бин будут создавать только при наличии
положительного значения константы в файле с пропертями. Например:

```java

@ConditionalOnProperty(
        value = "project.mq.enabled",
        matchIfMissing = false)
@Configuration
public class JmsConfig {
       ...
}
```

Если project.mq.enabled=true - бин будет создан, если false - нет.

---

## Как работает `@Transactional`?

Она указывает метод, который должен выполняться внутри транзакции базы данных. При использовании на уровне
класса `@Transactional` применяется ко всем методам этого класса и его подклассов.

Аннотация `@Transactional` автоматически создаст транзакцию при вызове метода, а коммит или откат будут управляться
Spring
неявно. Таким образом, декларативное управление транзакциями позволяет сократить объем шаблонного кода.

> Имейте в виду, что декларативная разметка работает только в том случае, если метод вызывается в экземпляре,
> инжектированном в другой бин, или полученном с помощью ApplicationContext.getBean(), то есть через созданный
> контейнером
> прокси. Вызов аннотированного метода из другого метода того же объекта не приведет к запуску транзакции.

---

## Всегда ли откатываются транзакции в `@Transactional`

Нет. За откат транзакций отвечает параметр rollbackFor, который по дефолту имеет RuntimeException. Если будет выброшено
исключение, например, Exception, тогда транзакция не откатится.

---

## Для чего используются в `@Transactional` параметры isolation и propagation?

Isolation указывает на уровень изоляции транзакций. Бывает:

* Isolation.READ_UNCOMMITTED
* Isolation.READ_COMMITTED
* Isolation.REPEATABLE_READ
* Isolation.SERIALIZABLE

Propagation отвечает за принцип распространения транзакции. Бывает:

* `REQUIRED` - распространение по умолчанию. Если есть активная транзакция, тогда бизнес-логика продолжается в ней, если
  нет - тогда создается новая.
* `SUPPORTS` - если есть активная транзакция, тогда бизнес-логика продолжается в ней, если нет - тогда бизнес-логика
  выполнится без транзакции.
* `MANDATORY` - если есть активная транзакция, тогда бизнес-логика продолжается в ней, если нет - будет выброшено
  исключение IllegalTransactionStateException.
* `NEVER` - если есть активная транзакция, тогда Spring выбросит исключение IllegalTransactionStateException.
* `NOT_SUPPORTED` - если есть активная транзакция, тогда она будет приостановлена, а бизнес логика выполнится без нее.
* `REQUIRES_NEW` - если есть активная транзакция, тогда она будет приостановлена и создана новая. Если транзакции не
  было, она будет создана.
* `NESTED` - если транзакция существует, тогда будет помечена точка сохранения. Это означает, что если наше выполнение
  бизнес-логики создает исключение, то транзакция откатывается к этой точке сохранения. Если активной транзакции нет,
  она работает как REQUIRED.

---

## Чем отличается интеграционное и unit-тестирование?

В unit-тестировании проверяется работа какого-то одного конкретного модуля (класса) в изолированном состоянии, чтобы
другие модули не оказывали на него воздействие или чтобы оно было заранее предопределено с помощью заглушек или моков.
В интеграционном тестировании проверяется взаимодействие между различными модулями. Тестируется работа с базой данных,
брокерами сообщений.

---

## Как поднимал тестовую базу?

Через testcontainers. А потом с помощью скриптов накатывал DDL и DML.

---

## Как тестировать внешние сервисы?

Для тестирования внешних сервисов предпочтительно использовать заглушки/моки, так как обращение к реальным сервисам
может быть не оптимально, небезопасно, может плохо сказываться на работе тестов.

---

## Методы HTTP

* GET
* HEAD
* POST
* PUT
* PATCH
* DELETE
* и другие

---

## Какие методы идемпотентны?

> Идемпотентные методы - это методы, которые либо не изменяют состояние в базе данных, либо изменяют состояние только
> при
> первом запросе. В случае повторной отправки идентичного запроса, состояние в базе данных не изменяется.

Идемпотентными методами являются: GET, PUT, DELETE, HEAD и OPTIONS. POST и PATCH не входят в эту группу.

---

## Можно ли создать сущность методом GET?

Можно, но не нужно.

---

## Какие существуют группы статусов в HTTP?

* 1** - информационные
* 2** - успешные
* 3** - перенаправления
* 4** - клиентские ошибки
* 5** - серверные ошибки

---

## Где какой выбрать статус код?

200 - Запрос успешно отработан и возвращен.
201 - Ответ на POST-запрос.
202 - Запрос принят, но не обработан.
204 - Нет содержимого. Например, после DELETE-метода.

400 - Некорректные параметры запроса.
401 - Нужна авторизация (она возможна).
403 - Запрещено (авторизация невозможна).
404 - Ресурс не найден.

500 - Ошибка на сервере.
503 - Сервер не доступен.

---

## Как обрабатываются ошибки в Spring?

Для этого можно использовать класс с аннотацией `@ControllerAdvice`. И написать методы, которые будут выполнять роль
хандлеров для исключений, используя аннотацию `@ExceptionHandler(Exception.class)`.

---

## Через что обращаться к другим сервисам?

RestTemplate или FeignClient.

---

## RestTemplate или FeignClient

RestTemplate представляет более низкоуровневое решение, нежели FeignClient. Но в то же время оно является более гибким.

FeignClient обеспечивает более высокий уровень абстракции. Он работает по декларативному принципу. Мы просто используем
интерфейс и нет необходимости заботиться о реализации.

Сейчас наблюдается тенденция перехода на FeignClient, если нет каких-то специфичных требований для выполнения запросов.

---

## Как кастомизировать ошибки в FeignClient?

Для этого необходимо создать хандлер в `@ControllerAdvice` классе и, который ловит `FeignException` и провести обработку
исключения.

---

## DateTime Java 8. Offset vs Zoned

```java
ZoneOffset zoneOffSet=ZoneOffset.of("+02:00");
        OffsetDateTime offsetDateTime=OffsetDateTime.now(zoneOffSet);
```

```java
ZoneId zone=ZoneId.of("Europe/Berlin");
        ZonedDateTime zonedDateTime=ZonedDateTime.now(zone);
```

> Предпочтение следует отдавать OffsetDateTime для хранения в БД или для передачи по сети, так как даты со смещением по
> местному времени всегда представляют одни и те же моменты времени.

#### OffsetDateTime:

* сохраняет все поля даты и времени с точностью до наносекунд, а также смещение от GMT/UTC (без информации о часовом
  поясе).
* следует использовать для хранения даты в базе данных или передачи ее по сети.

#### OffsetDateTime:

* хранит все поля даты и времени с точностью до наносекунд и часовой пояс со смещением зоны, используемым для обработки
  неоднозначных локальных дат и времени.
* нельзя свободно устанавливать смещения, так как зона контролирует допустимые значения смещения.
* полностью поддерживает летнее время и корректирует летнее время.
* пригодится для отображения полей даты и времени в пользовательском часовом поясе.

---

## Как исправить баг со временем в тестах?

Я бы сделал static mock для LocalDateTime.now().

---

## Для чего нужен Optional. Защищает ли он от NPE. Негативные последствия от использования его в качестве параметра метода

Можно воспринимать `Optional`, как некую коробку, обертку, в которую кладется какой-либо объект. `Optional` всего лишь
контейнер: он может содержать объект некоторого типа Т, а может быть пустым.

Он помогает избежать длинных проверок на null.

Optional не защищает в полной степени от null.

> Не стоит использовать Optional, в качестве параметра метода. Если пользователь метода с параметром Optional не знает
> об этом, он может передать методу null вместо Optional.empty(). И обработка null приведет к исключению
> NullPointerException.

---

## Как ты принимаешь решение: делать Exception checked или unchecked?

Checked Exception можно делать в том случае, если есть необходимость, чтобы исключение обработал пользователь моего
кода. Во всех остальных случаях предпочтительнее использовать unchecked exceptions.

Роберт Мартин в книге "Чистый код" советует не использовать checked exceptions.

---

## Mutable и immutable. Как сделать объект immutable

Чтобы создать immutable класс, необходимо:

1. Сделать класс final
2. Сделать все поля private
3. Не создавать конструктор по умолчанию и сеттеры для полей
4. В конструкторе с параметрами и геттерах проводить глубокое копирование получаемого/передаваемого объекта.
