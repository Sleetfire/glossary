## Основные термины и понятия Docker

* `Docker host` — это операционная система, на которую устанавливают Docker и на которой он работает.
* `Docker daemon` — служба, которая управляет Docker-объектами: сетями, хранилищами, образами и контейнерами.
* `Docker client` — консольный клиент, при помощи которого пользователи взаимодействуют с Docker daemon и отправляют ему
  команды, создают контейнеры и управляют ими.
* `Docker image` — это неизменяемый образ, из которого разворачивается контейнер.
* `Docker container` — развёрнутое и запущенное приложение.
* `Docker Registry` — репозиторий, в котором хранятся образы.
* `Dockerfile` — файл-инструкция для сборки образа (скрипт).
* `Docker Compose` — инструмент для управления несколькими контейнерами. Он позволяет создавать контейнеры и задавать их
  конфигурацию.
* `Docker Desktop` — GUI-клиент, который распространяется по GPL. Это очень удобный клиент, который отображает все
  сущности Docker и позволяет запустить однонодовый Kubernetes для компьютера.

> Docker изначально создавался под Linux. Поэтому на Windows и macOS запускают виртуальную машину с Linux, а поверх
> неё — Docker. В macOS используют VirtualBox, а в Windows — Hyper-V.
> Работа поверх виртуалок повышает потребление ресурсов. Поэтому Docker на macOS и Windows работает медленнее и с рядом
> ограничений. Для разработки это приемлемо, но «в бою» так делать никто не будет. На всех популярных платформах в проде
> используют Linux.

---

## Чем отличается виртуализация от контейнеризации?

Контейнеры и виртуальные машины — это разные способы виртуализации. Только виртуалка реализует её на уровне железа, а
Docker — на уровне операционной системы.

Виртуальная машина функционирует как отдельный компьютер с собственным оборудованием и операционной системой. Сервер
«нарезается» на много виртуальных компьютеров, что избавляет нас от необходимости покупать их отдельно. Виртуальные
компьютеры вполне полноценны. На них можно установить операционную систему любого семейства и работать в ней, например,
через графический интерфейс в многопользовательском режиме, устанавливая и запуская множество приложений и сервисов.

Основная цель Docker — создать среду для одного приложения. Виртуальная среда контейнера запускается внутри операционной
системы. Ей не нужно виртуализировать оборудование — она использует его через ОС. Поэтому контейнеры Docker потребляют
меньше ресурсов, быстрее развёртываются, проще масштабируются и меньше весят.

Оба способа изолируют приложение от основной операционной системы, но если на виртуалку можно поставить любую ОС, то
Docker ориентирован на ядро Linux.

---

## Сущности Docker

`Docker image (образ)`. Это шаблон, по которому создают контейнеры. Его часто сравнивают со слоёным пирогом: мы
накладываем слой файловой системы поверх слоя базового образа и получаем неизменяемый образ. В него можно установить
приложение, конфигурации и зависимости. Другие образы могут наследоваться, поэтому если положить сверху слой файлов и
закоммитить, то мы получим ещё один неизменяемый образ.

`Dockerfile`. Если Docker image — это пирог, то Dockerfile — рецепт его приготовления. В этом файле описаны основные
инструкции для сборки образа: какой базовый образ взять, откуда и куда положить файлы и так далее.

`Контейнер` — это runtime-сущность на основе образа, приложение, которое мы развернули с помощью Docker. Можно провести
такую аналогию: образ — это инсталлятор программы, а контейнер — уже запущенная программа.

`Docker Registry`. Это репозиторий, в котором хранятся Docker-образы. Он может быть как локальным, так и публичным.
Репозитории создают на платформах вроде Docker Hub и GitLab и размещают в них образы с описанием, разными версиями и
тегами.

---

## Основные команды

`docker run image_id` - запускаем создание контейнера из образа.

`docker build .` - создаем образ из Dockerfile, который лежит в корневой папке.

`docker start container_id` - стартуем докер контейнер.

`docker stop container_id` - останавливаем докер контейнер.

`docker run -p 3000:8080 image_id` - создаем контейнер, указывая внешний порт (3000) и внутренний (8080).

`docker run -d image_id` - создаем контейнер, -d (detach) указывает, что не нужно переходить в консоль контейнера.

`docker images` - просмотр всех образов.

`docker ps` - просмотр всех работающих контейнеров.

`docker ps -a` - просмотр всех контейнеров.

`docker container prune` - удаление неактивных контейнеров.

`docker image ls` - альтернативный способ просмотра всех образов.

`docker attach container_id` - подключение к существующему контейнеру.

`docker logs container_id` - просмотр логов контейнера.

`docker rm container_id` - удаление контейнера.

`docker rmi image_id` - удаление образа.

`docker build -t image_name .` - создание образа из Dockerfile, лежащего в текущей папке. `-t image_name` отвечает за
создание имени образа в репозитории.

`docker build -t image_name:version .` - здесь version - версия образа.

`docker image history image_id` - посмотреть историю создания образа.

`docker image inspect image_id` - посмотреть расширенную историю образа.

`docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]` - позволяет зафиксировать изменения файла контейнера или
настройки в новом образе. Но лучше использовать докер файл.

`docker save [OPTIONS] IMAGE [IMAGE...]` - позволяет сохранить докер-образ в виде
файла.  `docker save busybox > busybox.tar`

---

## Структура Dockerfile

```dockerfile
FROM eclipse-temurin:17-alpine 
WORKDIR /app
COPY . .
RUN
CMD ["java", "-jar", "app-snapshot.jar"]
EXPOSE 8080
```

`FROM eclipse-temurin:17-alpine ` - отсюда берем jdk.

`WORKDIR /app` - место, куда будет помещен jar-файл в контейнере.

`COPY . .` - копируем откуда (локально) куда

`RUN` - здесь указываем то, что должно быть прописано в консоли при сборке образа.

`CMD ["java", "-jar", "app-snapshot.jar"]` - то, что будет писаться в консоль при каждом запуске контейнера.

`EXPOSE 8080` - указываем внутренний порт контейнера.

---

# Основные команды Dockerfile

`FROM` - задает базовый родительский образ

`LABEL` - описывает метаданные. Например, кто создал и поддерживает образ

`ENV` - настраивает постоянные переменные среды

`RUN` - создает слой образа. Используется для установки в контейнер пакетов

`COPY` - копирует в контейнер файлы и папки

`ADD` - копирует в контейнер файлы и папки, может распаковывать локальные .tar-файлы

`CMD` - описывает команду с аргументами, которая будет выполняться при каждом запуске контейнера

`WORKDIR` - задает рабочую директорию

`ARG` - задает переменные для передачи Docker во время сборки Docker-образа

`ENTRYPOINT` - представляет команду с аргументами для вызова во время выполнения контейнера

`EXPOSE` - указывает на необходимость открыть порт

`VOLUME` - создает точку монтирования для работы с постоянным хранилищем

---

# Тома Docker

Том — это файловая система, которая расположена на хост-машине за пределами контейнеров. Созданием и управлением томами
занимается Docker. Вот основные свойства томов Docker:

* Они представляют собой средства для постоянного хранения информации.
* Они самостоятельны и отделены от контейнеров.
* Ими могут совместно пользоваться разные контейнеры.
* Они позволяют организовать эффективное чтение и запись данных.
* Тома можно размещать на ресурсах удалённого облачного провайдера.
* Их можно шифровать.
* Им можно давать имена.
* Контейнер может организовать заблаговременное наполнение тома данными.
* Они удобны для тестирования.

`docker volume create —-name my_volume`

`docker volume ls`

`docker volume inspect my_volume`

`docker volume rm my_volume`

`docker volume prune`

---

# Docker Swarm

`Swarm` это стандартный оркестратор для docker контейнеров, доступный из «коробки», если у вас установлен сам docker.

* **Node** - это наши виртуальные машины, на которых установлен docker. Есть `manager` и workers `ноды`. Manager нода
  управляет
  workers нодами. Она отвечает за создание/обновление/удаление сервисов на workers, а также за их масштабирование и
  поддержку в требуемом состоянии. Workers ноды используются только для выполнения поставленных задач и не могут
  управлять кластером.
* **Stack** - это набор сервисов, которые логически связаны между собой. По сути это набор сервисов, которые мы
  описываем в
  обычном compose файле. Части stack (services) могут располагаться как на одной ноде, так и на разных.
* **Service** - это как раз то, из чего состоит stack. Service является описанием того, какие контейнеры будут
  создаваться.
  Если вы пользовались docker-compose.yaml, то уже знакомы с этой сущностью. Кроме стандартных полей docker в режиме
  swarm поддерживает ряд дополнительных, большинство из которых находятся внутри секции deploy.
* **Task** - это непосредственно созданный контейнер, который docker создал на основе той информации, которую мы указали
  при
  описании service. Swarm будет следить за состоянием контейнера и при необходимости его перезапускать или перемещать на
  другую ноду.

---

# Docker-compose

```yaml
version: "3.9"

services:
  db:
    image: mysql:5.7
    volumes:
      - db_data:/var/lib/mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: goodpassword
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress

  wordpress:
    depends_on:
      - db
    image: wordpress:latest
    ports:
      - "8000:80"
    restart: always
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
volumes:
  db_data: { }
```

### Networks

* `driver` - Сетевой драйвер по умолчанию. Если вы не указываете драйвер, это тот тип сети, который вы создаете. Этот
  тип обычно используется, когда ваше приложение запускается в контейнере, которому необходимо взаимодействовать с
  другими контейнерами на том же хосте.
* `host` - Удаляет сетевую изоляцию между контейнерами и докер-хостом. Позволяет напрямую использовать сеть хоста.
* `overlay` - Оверлейные сети соединяют несколько демонов Docker вместе и позволяют службам Swarm и контейнерам
  взаимодействовать между узлами. Эта стратегия устраняет необходимость в маршрутизации на уровне операционной системы.
* `ipvlan` - Сети IP vlan предоставляют пользователям полный контроль как над адресацией IPv4, так и над адресацией
  IPv6. Драйвер VLAN основан на этом, предоставляя операторам полный контроль над маркировкой VLAN уровня 2 и даже
  маршрутизацией IP vlan L3 для пользователей, заинтересованных в интеграции с базовой сетью.
* `macvlan` - Сети Mac vlan позволяют вам назначать MAC-адрес контейнеру, чтобы он отображался как физическое устройство
  в вашей сети. Демон Docker направляет трафик к контейнерам по их MAC-адресам. Использование драйвера macvlan иногда
  является лучшим выбором при работе с устаревшими приложениями, которые ожидают прямого подключения к физической сети,
  а не маршрутизируются через сетевой стек хоста Docker.
* `none` - Полностью изолирует контейнер от хоста и других контейнеров. Ни один из них не доступен для служб Swarm

---

# Дополнительная информация

> Файл .dockerignore является инструментом, который может использоваться для уточнения контекста сборки Docker.
> Используя
> этот файл, можно задать правила исключения файлов из контекста сборки, а значит уменьшить время, необходимое на сборку
> tar-архива и отправку его на сервер.