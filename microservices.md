## Monolith vs microservices

#### Преимущества монолитной архитектуры

* **Простое развертывание.** Использование одного исполняемого файла или каталога упрощает развертывание.
* **Разработка.** Приложение легче разрабатывать, когда оно создано с использованием одной базы кода.
* **Производительность.** В централизованной базе кода и репозитории один интерфейс API часто может выполнять ту
  функцию,
  которую при работе с микросервисами выполняют многочисленные API.
* **Упрощенное тестирование.** Монолитное приложение представляет собой единый централизованный модуль, поэтому сквозное
  тестирование можно проводить быстрее, чем при использовании распределенного приложения.
* **Удобная отладка.** Весь код находится в одном месте, благодаря чему становится легче выполнять запросы и находить
  проблемы.

#### Недостатки монолитной архитектуры

> Как и в случае с Netflix, монолитные приложения работают достаточно эффективно до тех пор, пока они не становятся
> слишком большими и не вызывают проблем с масштабированием. Чтобы внести небольшое изменение в одну функцию, необходимо
> выполнить компиляцию и тестирование всей платформы, что противоречит agile-подходу, которому отдают предпочтение
> современные разработчики.

* **Снижение скорости разработки.** Большое монолитное приложение усложняет и замедляет разработку.
* **Масштабируемость.** Невозможно масштабировать отдельные компоненты.
* **Надежность.** Ошибка в одном модуле может повлиять на доступность всего приложения.
* **Препятствия для внедрения технологий.** Любые изменения в инфраструктуре или языке разработки влияют на приложение
  целиком, что зачастую приводит к увеличению стоимости и временных затрат.
* **Недостаточная гибкость.** Возможности монолитных приложений ограничены используемыми технологиями.
* **Развертывание.** При внесении небольшого изменения потребуется повторное развертывание всего монолитного приложения.

#### Преимущества микросервисов

> Микросервисы не являются волшебной палочкой, но они решают ряд проблем, с которыми сталкиваются растущие компании при
> развитии ПО. Поскольку архитектура микросервисов состоит из независимо работающих модулей, каждую службу можно
> разрабатывать, обновлять, развертывать и масштабировать отдельно от остальных. Обновления можно выполнять чаще,
> повышая
> надежность, время бесперебойной работы и производительность программного обеспечения.

* **Гибкость.** Продвигайте гибкие методы работы среди небольших команд, которые регулярно выполняют развертывание.
* **Гибкое масштабирование.** Когда микросервис достигает предельной нагрузки, можно быстро выполнить развертывание
  новых
  экземпляров данной службы в сопутствующем кластере и снизить нагрузку. Теперь мы работаем с несколькими держателями и
  без сохранения состояния, а клиенты распределены по различным экземплярам. С таким подходом мы можем поддерживать
  экземпляры гораздо большего размера.
* **Непрерывное развертывание.** Теперь у нас есть регулярные и ускоренные циклы релиза. Раньше мы выпускали обновления
  раз
  в неделю, а теперь можем делать это примерно два-три раза в день (чего???).
* **Легкость обслуживания и тестирования.** Команды могут экспериментировать с новыми функциями и возвращаться к
  предыдущей
  версии, если что-то не работает. Это упрощает обновление кода и ускоряет выпуск новых функций на рынок. Кроме того, в
  отдельных службах легко находить и исправлять ошибки и баги.
* **Независимое развертывание.** Микросервисы представляют собой отдельные модули, поэтому с ними можно легко и быстро
  выполнять независимое развертывание отдельных функций.
* **Гибкость технологий.** При использовании архитектуры микросервисов команды могут выбирать инструменты с учетом своих
  предпочтений.
* **Высокая надежность.** Развертывая изменения для конкретной службы, можно не бояться, что приложение выйдет из строя
  целиком.

#### Недостатки микросервисов

* **Разрастание процесса разработки.** Микросервисы усложняют работу по сравнению с монолитной архитектурой, поскольку в
  различных местах возникает все больше служб, созданных несколькими командами. Если разрастание не контролируется
  должным образом, оно приводит к замедлению разработки и снижению операционной эффективности.
* **Экспоненциальный рост расходов на инфраструктуру.** У каждого нового микросервиса может быть своя стоимость
  комплекта
  тестов, инструкций по развертыванию, инфраструктуры хостинга, инструментов мониторинга и т. д.
* **Дополнительные организационные расходы.** Командам требуется дополнительный уровень коммуникации и сотрудничества,
  чтобы
  координировать работу над обновлениями и интерфейсами.
* **Проблемы при отладке.** У каждого микросервиса свой набор журналов, что усложняет отладку. Кроме того,
  дополнительные
  затруднения могут возникать в том случае, когда один бизнес-процесс выполняется на нескольких машинах.
* **Отсутствие стандартизации.** Без общей платформы может возникнуть ситуация, в которой расширяется список языков,
  стандартов ведения журналов и средств мониторинга.
* **Отсутствие ясности в вопросах владения.** По мере появления новых служб увеличивается и количество работающих над
  ними
  команд. Со временем становится сложнее определить, какие службы команда может использовать и к кому следует обращаться
  за поддержкой.

---

## Взаимодействие между микросервисами

Микросервисы взаимодействуют друг с другом через API-интерфейсы, такие, как REST или gRPC, но не обладают информацией о
внутреннем устройстве других сервисов. Такое согласованное взаимодействие между микросервисами называется микросервисной
архитектурой.

#### Синхронные способы общения - мы делаем вызов и ждем получения ответа:

* **Синхронный REST-like и аналоги.** В чистом виде REST встречается редко, но в целом он один из самых популярных. При
  желании через костыли его можно сделать “асинхронным”, но этот случай мы тут не будем рассматривать.
* **gRPC** - RPC на бинарном формате сообщений поверх HTTP/2 от Google.
* **SOAP** - RPC с форматом XML. Это решение очень любили использовать в enterprise, оно чаще встречается в более старых
  системах.

#### Асинхронные способы общения - мы отправляем сообщение, а ответ придет когда-нибудь потом или он в принципе не предусмотрен:

* **Месседжинг** - RabbitMQ, ZeroMQ, ActiveMQ. Они все разные, и об этом мы далее поговорим.
* **Стриминг** - Kafka. В принципе, Kafka похожа на мессенджинговую платформу, но я выделил ее отдельно, т.к. отличия
  все-таки есть.

#### gRPC:

* Использует бинарный формат Protobuf - утилизация трафика лучше, можно слать только значения, не передавая ключи.
  Конечно, ты не можешь прочитать в консоли сообщение глазами, как мог бы это сделать с JSON (приходится писать
  дополнительную утилиту, которая будет его парсить перед тем, как прочитать). Зато на больших нагрузках все это будет
  лучше работать.
* Есть схема данных, по которой генерируется DTO на запрос / ответ. С жесткой схемой работать удобнее, Protobuf
  накладывает ограничения на изменение схемы данных, чтобы сохранялась обратная совместимость. Это и плюс, и иногда
  минус.
* Можно передавать не один запрос, а слать объекты один за другим - стримить.
* Есть встроенный механизм backpressure - если сообщения отправляются слишком быстро и получатель не может их
  “переварить”, этот механизм позволяет замедлить передачу.
* Отправка запроса выглядит, как вызов метода в коде, используется RPC-стиль.

---

## Паттерны микросервисной архитектуры

#### Группы паттернов:

* **Паттерны декомпозиции на микросервисы:**
    * Шаблон «Разбиение по бизнес-возможностям» (Decompose By Business Capability)
    * Шаблон «Разбиение по поддоменам» (Decompose By Subdomain)
* **Паттерны рефакторинга для перехода на микросервисы:**
    * Шаблон «Душитель» (Strangler)
    * Шаблон «Уровень защиты от повреждений» (Anti-Corruption Layer)
* **Паттерны управления данными в микросервисной архитектуре:**
    * Шаблон «База данных на сервис» (Database Per Service)
    * Шаблон «API-композиция» (API Composition)
    * Шаблон «Разделение команд и запросов» (Command Query Responsibility Segregation, CQRS)
    * Шаблон «Поиск событий» (Event Sourcing)
    * Шаблон «Сага» (Saga)
* **Паттерны коммуникации микросервисов:**
    * Шаблон «API-шлюз» (API Gateway)
    * Шаблон «Бэкенды для фронтендов» (Backends for Frontends, BFF)
* **Паттерны построения пользовательского интерфейса**
    * Шаблон «Сборка пользовательского интерфейса на стороне клиента» (Client-Side UI Composition)
    * Шаблон «Сборка фрагментов страниц на стороне сервера» (Server-Side Page Fragment Composition)
* **Паттерны обнаружения сервисов в микросервисной архитектуре:**
    * Шаблон «Обнаружение сервисов на стороне клиента» (Client-Side Service Discovery)
    * Шаблон «Обнаружение сервисов на стороне сервера» (Server-Side Service Discovery)
* **Паттерны развертывания микросервисов:**
    * Шаблон «Экземпляр сервиса на хост» (Service Instance Per Host)
    * Шаблон «Сине-зеленое развертывание» (Blue-Green Deployment)
* **Паттерны повышения отказоустойчивости:**
    * Шаблон «Автоматический выключатель» (Circuit Breaker)
    * Шаблон «Переборка» (Bulkhead)
* **Паттерны мониторинга микросервисов:**
    * Шаблон «Агрегация логов» (Log Aggregation)
    * Шаблон «Распределенная трассировка» (Distributed Tracing)
    * Шаблон «Проверки здоровья» (Health Check)
* **Прочие паттерны проектирования микросервисов:**
    * Шаблон «Посредник» («Посол», Ambassador)
    * Шаблон «Коляска» («Прицеп», Sidecar)
    * Шаблон «Тестирование контрактов, ориентированных на потребителя» (Consumer-Driven Contract Testing)
    * Шаблон «Внешняя конфигурация» (External Configuration)

[Больше информации](https://mcs.mail.ru/blog/26-osnovnyh-patternov-mikroservisnoj-razrabotki)
