## Что такое Hibernate?

Java — объектно-ориентированный язык программирования. Это значит, что в коде, написанном на Java, разные функции и другие сущности хранятся в виде объектов. Перенести эти объекты в базу данных напрямую нельзя — обычные БД не поддерживают такую объектную структуру. Чтобы всё-таки произвести перенос, существует объектно-реляционная модель (от англ. ORM, Object Relational Mapping). Она позволяет создать из объектов кода «виртуальную» базу данных и хранить связи между объектами в реальной базе.
Если описывать упрощённо, ORM предлагает присвоить столбцу имя переменной объекта кода, а в строку записать значение. Причём типы данных должны определяться автоматически. Всё это требует настройки, и без специальных инструментов приходилось бы проводить все операции вручную. К счастью, готовые инструменты для автоматизации этого процесса существуют.

> Hibernate — это инструмент, который как раз работает по ORM. Он работает на особом наборе правил — спецификации JPA 2.1. Она описывает, как именно можно сохранять данные из Java-кода в базы, однако это только теоретические правила. Hibernate превращает теорию в практику и позволяет загружать объекты из кода Java в базы данных напрямую.

Hibernate называют и фреймворком, и библиотекой. Конкретно в этом случае эти понятия равнозначны, так как Hibernate содержит и наборы правил, и конкретные функции для работы с кодом.

---

## Плюсы и минусы Hibernate

#### Плюсы:
* **Популярность.** По фреймворку много статей, обсуждений и уроков, на любой вопрос найдётся ответ.
* **Поддержка других инструментов.** Большинство библиотек и фреймворков Java работают с Hibernate без нареканий и сложных интеграций.
* **Облегчение кода.** С фреймворком программисту не нужно постоянно писать десятки одинаковых строк кода — программа становится понятнее, лаконичнее и легче.
* **Освобождение от рутины.** Разработчику не нужно писать огромное число запросов и «скучного» рутинного кода. Этим займётся Hibernate, и можно будет сосредоточиться на действительно сложных задачах, требующих творческого подхода.
* **Независимость от баз данных.** Не важно, какая БД используется в текущем проекте, — через Hibernate разработчику легко будет с ней работать.

#### Минусы:
* **Сложность в освоении.** Чтобы правильно писать код с Hibernate, нужно понимать принципы работы баз данных и знать синтаксис библиотеки. Этому придётся учиться.
* **Низкая производительность при использовании сложных моделей данных.** Несмотря на «ленивую загрузку», код, написанный с помощью Hibernate, обычно чуть медленнее и тяжелее чистого.
* **Непредсказуемость.** Из-за особенностей спецификации JPA значения в коде иногда могут изменяться, когда разработчики этого не задумывали. Такие моменты важно подмечать во время тестирования.
* **Неполное кэширование.** Кэш помогает улучшить производительность, однако в Hibernate нельзя кэшировать изменяемые функции. Это накладывает на разработчиков некоторые ограничения.

---

## Конфигурация подключения Hibernate

> Hibernate требуется заранее знать, где найти информацию о сопоставлении, которая определяет, как ваши Java классы
> связаны с таблицами базы данных. Hibernate также требует набора параметров конфигурации, связанных с базой данных и
> других связанных параметров.

Сконфигурировать можно с помощью:

* XML-конфигурации (файл hibernate.cfg.xml).
* Properties-файла (hibernate.properties).
* Опции виртуальной машины (VM options).
* Java-конфигурации.

**Сконфигурировать** - например, указать url для доступа к базе данных, username, password, класс драйвера, SQL-диалект
для конкретной базы и т. д.

Для маппинга сущностей можно использовать следующие способы:

* XML-конфигурация.
* Java-аннотации.

---

## Основные свойства XML-конфигурации

`hibernate.dialect` - Это свойство заставляет Hibernate генерировать соответствующий SQL для выбранной базы данных.

`hibernate.connection.driver_class` - Класс драйвера JDBC.

`hibernate.connection.url` - URL JDBC для экземпляра базы данных.

`hibernate.connection.username` - Имя пользователя базы данных.

`hibernate.connection.password` - Пароль базы данных.

`hibernate.connection.pool_size` - Ограничивает количество соединений, ожидающих в пуле соединений базы данных Hibernate.

`hibernate.connection.autocommit` - Позволяет использовать режим автоматической фиксации для соединения JDBC.

---

## Пример XML-конфигурации для MySQL

```xml
<?xml version = "1.0" encoding = "utf-8"?>
<!DOCTYPE hibernate-configuration SYSTEM 
"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
   <session-factory>
   
      <property name = "hibernate.dialect">
         org.hibernate.dialect.MySQLDialect
      </property>
      
      <property name = "hibernate.connection.driver_class">
         com.mysql.jdbc.Driver
      </property>
      
      <!-- test - это имя базы данных -->
      <property name = "hibernate.connection.url">
         jdbc:mysql://localhost/test
      </property>
      
      <property name = "hibernate.connection.username">
         root
      </property>
      
      <property name = "hibernate.connection.password">
         root123
      </property>
      
      <!-- Маппинг сущности с помощью XML-конфигурации -->
      <mapping resource = "Employee.hbm.xml"/>
      
   </session-factory>
</hibernate-configuration>
```

---

## Основные аннотации

`@Basic` - указывает, что тип поля, на котором висит аннотация, является базовым и Hibernate должен использовать стандартную стратегию маппинга для его сохранения в базу данных. Аннотация является опциональной и имеет два параметра:
* `optional` - указывает на то, может ли быть поле null. Тип: boolean.
* `fetch` - указывает, каким образом должна происходить загрузка этого поля в сущность: FetchType.LAZY (лениво) или FetchType.EAGER (жадно).

`@Column` - позволяет задавать параметры колонки (поля) в базе данных. Имеет следующие параметры:
* `columnDefinition` - здесь используется фрагмент SQL-кода во время генерации DDL для колонки. Тип: String.
* `insertable` - включать ли столбец в операцию SQL INSERT. Тип: boolean.
* `length` - задает длину колонки в БД. Тип: int.
* `name` - задает имя колонки в БД. Тип: String.
* `nullable` - задает, может ли быть колонка быть null. Тип: boolean.
* `precision` - задает точность для дробного числа. Тип: int.
* `scale` - задает масштаб десятичного числа. Тип: int.
* `table` - задает имя таблицы, которая содержит данную колонку. Тип: String.
* `unique` - задает уникальность колонки в БД. Тип: boolean.
* `updatable` - задает опцию, включать ли столбец в инструкцию SQL UPDATE. Тип: boolean.

`@Type` - позволяет явно указать Hibernate тип для маппинга. 

`@Enumerated` - позволяет указать стратегию для маппинга у enum.
* `EnumType.ORDINAL` - в БД запишется номер соответствующего значения.
* `EnumType.STRING` - в БД запишется строковое значение enum.

`@Temporal` - позволяет указать стратегию для маппинга у даты.
* `TemporalType.DATE` - сетает в БД только дату.
* `TemporalType.TIME` - сетает в БД только время.
* `TemporalType.TIMESTAMP` - сетает и дату, и время.

`@CreationTimeStamp` - автоматически сетает дату и время при создании объекта.

`@UpdateTimestamp` - автоматически сетает дату и время при обновлении объекта.

`@Formula("id + age")` - позволяет произвести операции над полями сущности. В данном случае будет сумма id и age.

`@Table` - позволяет указать настройки для таблицы. Имеет следующие параметры:
* `catalog` - указывается каталог таблицы. Тип: String.
* `indexes` - указываются индексы для таблицы. Тип: Index[].
* `name` - указывается имя таблицы. Тип: String.
* `schema` - указывается схема для таблицы. Тип: String.
* `uniqueConstraints` - указывается список ограничений, накладываемых на таблицу. Тип: UniqueConstraint[].

`@Id` - обязательная аннотация. Она вешается на поле, которое выполняет функцию идентификатора в БД. Если аннотация находится над полем, тогда доступ к полям класса будет осуществляться с помощью рефлексии. Если находится над методом get(), тогда доступ будет осуществляться через методы класса. 

`@Access` - позволяет указать тип доступа к полю сущности: через рефлексию или через методы класса.
* `AccessType.Field` - через рефлексию.
* `AccessType.PROPERTY` - через методы.

> Для Embeddable-классов можно указать эту аннотацию над классом.

`@Transient` - позволяет не сетать поле, над которым висит эта аннотация, в БД.

`@GeneratedValue` - позволяет автоматически генерировать id. У аннотации есть параметр strategy, который может принимать следующие значения:
* `GeneratedType.AUTO` (по умолчанию) - указывает, что Hibernate сам выбирает стратегию: или identity, или sequence, или table. Сначала попробует использовать sequence, если он не используется, тогда table.
* `GenerationType.IDENTITY` - БД сама генерирует id на основе своей внутренней последовательности (не все базы поддерживают эту стратегию). Используется внутренний в БД тип данных столбца identity.
* `GenerationType.SEQUENCE` - для генерации id используется специальный объект базы данных - последовательность.
* `GenerationType.TABLE` - создается новая таблица hibernate.sequence, в которой хранятся id.

`@EmbeddableId` - позволяет указать составной primary key на основе Embeddable-класса. Но для этого нужно наложить ряд ограничений на Embeddable-класс:
* Реализация интерфейса Serializable.
* Реализация методов equals() & hashCode().
* Конструктор без аргументов.

`@NaturalId` - указывает, что с полем нужно обращаться как с обычным id.

---

## Embeddable-объекты

> Embeddable-объекты - встраиваемые объекты. Для их использования необходимо пометить класс, который мы хотим объявить как поле, аннотацией `@Embeddable`. Если используем JPA, тогда еще необходимо вешать на поле аннотацию `@Embedded`. Также у Embeddable-класса должен быть конструктор по умолчанию.

---

## N + 1 проблема в Hibernate

> Проблема N + 1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL-запросов для получения тех же данных, которые можно получить при выполнении одного SQL-запроса.

Эта проблема часто возникает при работе с отношениями между сущностями один-ко-многим, один-к-одному, при жадной и ленивой загрузках. 

Проблему можно решить, используя join fetch в HQL. Но у этого метода есть недостатки. Например, использование методов `setMaxResults()` и `setFirstResult()`.

Также можно попробовать избавиться от проблемы, используя аннотацию
`@LazyToOne(LazyToOneOption.NO_PROXY)` для OneToOne или ManyToOne связи.
* `LazyToOneOption.NO_PROXY` - означает, что будет загружен реальный объект, а не прокси.
* `LazyToOneOption.FALSE` - жадная загрузка.
* `LazyToOneOption.PROXY` - означает, что будет загружен прокси-объект.

---

## Связь OneToOne

@OneToOne - указывается над полем, на которое хотим ссылаться. У этого поля есть параметры:
* `cascade` - отвечает за взаимодействие между Entity:
    * `CascadeType.REMOVE` - при удалении главной сущности из БД, удалится еще и сущность-поле.
    * `CascadeType.PERSIST` - если сохраняется главная сущность, тогда автоматически сохранится и ее поле.
    * `CascadeType.ALL` - применяются все каскадные взаимодействия.
    * `CascadeType.MERGE` - если обновляется главная сущность, вместе с ней обновляется и зависимая сущность.
    * `CascadeType.DETACH` - если удаляется главная сущность из сессии, вместе с ней удаляется и зависимая сущность.
    * `CascadeType.REFRESH` - если обновляется главная сущность, вместе с ней обновляется и зависимая сущность.
* `fetch` - отвечает за загрузку сущности:
  * `FetchType.EAGER` - загрузка сразу же.
  * `FetchType.LAZY` - ленивая (отложенная) загрузка.
* `orphanRemoval` - отвечает за удаление зависимой сущности, если будет удалена главная. Тип: boolean.
* `mappedBy = "leader"` - указывает хозяина отношений при двухсторонней связи. Это сделано для того, чтобы не дублировать информацию в таблице. О связи будет знать только та сущность, у которой была прописана данная аннотация.

> CascadeType можно комбинировать @OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})

---

## Связи OneToMany, ManyToOne и ManyToMany

Каждое из отношений может быть односторонним (unidirectional) или двусторонним (bidirectional).

```java
@OneToMany
private List<Contact> contacts;
```

```java
@ManyToOne
private Person person;
```

#### Односторонние отношения:

> Односторонним называется отношение, владельцем которого является только одна из двух сторон. Отсюда и название. Следует заметить, что при этом вторая сторона об этом отношении ничего не знает. Hibernate будет считать владельцем отношения ту сущность, в которой будет поставлена аннотация отношения.

Если использовать одностороннюю связь many-to-one, тогда у этой таблицы будет создана дополнительная колонка, в которой будет внешний ключ.
Если использовать одностороннюю связь one-to-many, тогда для связи двух таблиц будет создана еще одна дополнительная таблица, хранящая ссылки на ячейки первых двух таблиц. Чтобы решить эту проблему, можно использовать аннотацию @JoinColumn:

```java
@OneToMany
@JoinColumn(name = "person_id")
private List<Contact> contacts;
```

При таких настройках связь будет проводиться при помощи колонки `person_id`, а таблица связи создаваться не будет.

#### Двухсторонние отношения:

> У двусторонних отношений помимо стороны - владельца (owning side) имеется ещё и противоположная сторона (inverse side). Т.е. обе стороны отношения обладают информацией о связи. Логично предположить, что из одностороннего отношения можно сделать двустороннее просто добавив поле и аннотацию в класс сущности противоположной стороны.

Но при использовании двухсторонних отношений могут возникнуть некоторые проблемы. Например, может так получиться, что будут созданы две дополнительные таблицы, так как у нас по факту будет две односторонние связи. Чтобы Hibernate понял, что мы хотим создать именно двустороннее отношение, нам нужно указать, какая из сторон является владельцем отношений, а какая является обратной стороной. Это делается при помощи атрибута `mappedBy`. Важно отметить, что указывается этот атрибут в аннотации, которая находится на противоположной стороне отношения.

```java
// значение атрибута mappedBy - имя поля связи в классе сущности-владельца отношений
@ManyToMany(mappedBy = "roles")
private List<User> users;
```

Теперь Hibernate создаст только одну таблицу связи.

Также следует отметить, что в отношении один ко многим стороной-владельцем может быть только сторона многих (many), поэтому атрибут mappedBy есть только в аннотации `@OneToMany`.

#### Настройка объединяющей таблицы:

```
@JoinTable(
joinColumns = @JoinColumn(name = "id"),
inverseJoinColumns = @JoinColumn(name = "comment_id")
)
```

Эта аннотация позволяет контролировать и настраивать колонки в объединяющей таблице.

---

## Коллекции

#### Правила использования коллекций:

* Всегда использовать интерфейсы. Эта необходимость связана с тем, что proxy в hibernate работает только с интерфейсами. 
* В коллекциях можно использовать Embeddable-классы, указав над полем коллекции аннотацию `@ElementCollection`. Данная аннотация работает с коллекциями:
  * базовых типов (примитивные, String, Date, Wrappers).
  * Embeddable-классы.
  * Entity-классы.

Для каждой коллекции будет создаваться объединяющая таблица.

#### Сортировка коллекций:

`@OrderBy("column_name")` - сортировка аннотацией из JPA. Сортирует после получения данных из БД. Также вместо column_name можно просто указать название коллекции.

`@OrderColumn` - сортировка коллекции в БД. Параметры используются такие же, как и в @OrderBy.

`@OrderBy(clause = "marks DESC")` - сортировка из hibernate. Будет сортировать по "marks" по убыванию.

`@SortComparator(MyComparator.class)` - позволяет реализовать свой компаратор для сортировки.

---

## Динамическая модель Hibernate

Например, позволяет засетать в БД мапу. Но сначала нужно в конфиге прописать маппинг.

---

## Стратегии наследования

@Inheritance(strategy = InheritanceType.SINGLE_TABLE) - аннотация вешается на класс наследник

#### Существует 3 стратегии наследования:
* `InheritanceType.SINGLE_TABLE` (по умолчанию) - все данные будут в одной таблице (оптимальный вариант).
* `InheritanceType.JOINED` - будет создано несколько таблиц: одна для родителя и по таблице для каждого из наследников. В дополнительных таблицах будут храниться только те поле, которые есть у наследников.
* `InheritanceType.PER_CLASS` - так же, как и для JOINED, создает таблицы для родителя и наследников, но в таблицах наследников хранятся данные полностью, а не только дополнительные поля.

`@MappedSuperclass` - вешается на класс родителя, но обязательно нужно убрать с него аннотацию @Entity. Тогда получится, что у наследников будет по таблице на каждый класс. Там будут все поля.

---

## Состояния Entity

> Persistence contexts - контекст, который следит за состояниями Entity, чтобы они соответствовали тому, что находится в базе данных.

#### Всего есть 4 состояния:
* `transient` - Entity создана, но Persistence contexts еще не знает о ее существовании. Например, сущность была создана с помощью оператора new.
* `managed/persistent` - сущность была сохранена методом save()/persist(). Hibernate знает о существовании этой Entity.
* `detached` - сущность отделена от Persistence contexts. После этого изменения entity не отображаются в БД.
* `removed` - удаляем сущность. Для удаления используется метод remove().

Метод flush() позволяет выполнить накопившиеся SQL-команды.

Чтобы вернуть в состояние `managed/persistent` можно использовать методы:
* merge() - возвращает, если сущность уже была в persistent состоянии, а также если был вызван метод flush().
* update() - используется, если не вызывался flush().

Метод refresh() обновляет сущность относительно Persistence contexts. До этого чаще всего должен был быть вызван метод flush().

---

## Оптимистические и пессимистические блокировки

Для оптимистической блокировки необходимо использовать с аннотацией @Version. Поле может быть int, short, long, LocalDateTime, java.sql.Timestamp.

А на класс вешается аннотация @OptimisticLocking (hibernate annotation). У аннотации есть параметр type, который может принимать следующие значения:
* `OptimisticLockType.VERSION` - будет использоваться поле, помеченное аннотацией @Version.
* `OptimisticLockType.NONE` - поле с @Version использоваться не будет.
* `OptimisticLockType.ALL` - будем сверять все поля.
* `OptimisticLockType.DIRTY` - сравнение будет выполняться на основе "грязных" полей.

---

## Кэш в Hibernate

#### Кэш первого уровня

> Кэш первого уровня работает на уровне Session в Hibernate и на уровне EntityManager в JPA. Он используется, чтобы минимизировать количество запросов к базе данных. Сущность сохраняется сначала в кэше, а потом в БД. И когда есть необходимость получить сущность, она берется из кэша. 

#### Кэш второго уровня

> Кэш второго уровня работает на уровне SessionFactory в Hibernate, в JPA - на уровне EntityManagerFactory. Но есть проблема. Кэш второго уровня не реализован в Hibernate. Это нужно делать самому. Например, можно использовать реализацию ehcache. Вообще, реализаций существует достаточно много: некоторые работают быстрее, некоторые более вместительные.

Также кэшировать можно не только entity, но еще и query.

В JPA используется аннотация `@Cacheable`, которая указывает, что entity должна храниться в кэше второго уровня. 

В Hibernate используется аннотация `@Cache(usage = CacheConcurrencyStrategy.READ_ONLY)`. Она поддерживает 4 стратегии кэширования:
* `READ_ONLY` - загрузили в кэш 1 раз и часто читаем.
* `READ_WRITE` - читаем часто и пишем часто.
* `NONSTRICT_READ_WRITE` - в многопоточной среде записи должны происходить очень редко, иначе будет плохо.
* `TRANSACTIONAL` - устанавливает уровень изоляции БД на transaction.

#### Кэш запросов

> Кеш запросов похож на кеш второго уровня. Но в отличие от него — ключом к данным кеша выступает не идентификатор объекта, а совокупность параметров запроса. А сами данные — это идентификаторы объектов соответствующих критериям запроса. Таким образом, этот кеш рационально использовать с кешем второго уровня.

---

