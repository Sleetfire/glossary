## К какой классификации NoSQL относится? Какие основные отличия от РСУБД?

---

Относится к документным БД.

> Документная база данных – это тип нереляционных баз данных, предназначенный для хранения и запроса данных в виде
> документов в формате, подобном JSON. Документные базы данных позволяют разработчикам хранить и запрашивать данные в БД
> с
> помощью той же документной модели, которую они используют в коде приложения. Гибкий, полуструктурированный,
> иерархический характер документов и документных баз данных позволяет им развиваться в соответствии с потребностями
> приложений. Документная модель хорошо работает в таких примерах использования, как каталоги, пользовательские профили
> и
> системы управления контентом, где каждый документ уникален и изменяется со временем. Документные базы данных
> обеспечивают гибкость индексации, производительность выполнения стандартных запросов и аналитику наборов документов.

Основные отличия:

| MongoDB                                                                                                                                             | РСУБД                                                                                                       |
|:----------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------|
| Хранит данные в документах BSON, а затем организует их в коллекции.                                                                                 | Хранит данные в столбцах и строках. Хранение данных бывает табличным и реляционным.                         |
| Использует репликацию и сегментирование для горизонтального масштабирования                                                                         | Использует вертикальное масштабирование и чтение реплик для повышения производительности в нужном масштабе. |
| Использует язык запросов MongoDB (MQL)                                                                                                              | Использует SQL                                                                                              |
| Лучше всего справляется с вставкой или обновлением большого количества записей.                                                                     | Работает быстрее при выборе большого количества записей.                                                    |
| Не имеет схемы, что обеспечивает большую гибкость и позволяет работать с неструктурированными, полуструктурированными и структурированными данными. | Имеет жесткую схему, которая хорошо работает со структурированными данными.                                 |
| Использует сертификаты Kerberos, X.509 и LDAP для аутентификации пользователей.                                                                     | Использует встроенные методы аутентификации                                                                 |

## Позитивные и негативные сценарии использования MongoDB

---

#### Позитивные:

- гибкая система хранения информации: в приложениях необязательно преобразовывать объекты в элементы таблиц, не нужно
  пересоздавать схему базы при изменении структуры данных, например, при добавлении нового поля. В документах
  хранится информация разных типов, что важно при работе с большими данными, которые имеют разную структуру и взяты из
  разных источников
- базы легко масштабируются
- поддержка большинства современных языков программирования
- благодаря индексации, системе запросов и другим особенностям можно быстро искать, читать и записывать данные в базах
- базы MongoDB могут работать сразу на нескольких серверах: сегментирование позволяет распределять нагрузку, а
  репликация - создавать копии. Поэтому система работает быстро и без перебоев.

#### Негативные:

- в базах нет хранимых процедур, триггеров и внешних ключей, поэтому невозможно полностью автоматизировать работу.
- нет полного соответствия ACID.
- есть сложности при работе с транзакциями.

## JSON vs BSON

|         Критерий          | JSON                                          | BSON                                                                                                                                                                                                                  |
|:-------------------------:|-----------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|          Формат           | текстовый формат                              | бинарный формат                                                                                                                                                                                                       |
|        Типы данных        | дефолтные типы                                | поддерживает большее число типов данных: бинарные данные и доп. типы данных                                                                                                                                           |
|          Размер           | JSON можно сжать, например, с помощью Snappy. | в некоторых ситуациях данные могут быть меньше, чем в эквивалентных документах JSON, из-за двоичного кодирования и необязательного сжатия, но суммарный размер может быть увеличен из-за большой величины метаданных. |
| Поддержка / Совместимость | Является стандартом                           | Поддерживается только в MongoDB.                                                                                                                                                                                      |
|         Сложность         | Легкий                                        | более сложный, нежели JSON. Он требует дополнительные знания и инструменты для эффективной работы.                                                                                                                    |
|         Metadata          |                                               | BSON включает в себя дополнительные метаданные и информацию о типе, что увеличивает размер документа, но обеспечивает более богатый контекст для данных                                                               |

## Что есть Replica set?

---

> Replica Set — это кластер серверов MongoDB, реализующий механизм репликации master-slave и автоматическое переключение
> между ними. Это рекомендуемый механизм репликации от разработчиков MongoDB.
> Например, есть master, два slave и один arbiter

- Primary - основной сервер mongoDB
- Secondary - точные копии баз(ы) данных с real-time синхронизацией
- Arbiter - сервер выбора вторичной реплики с высшим приоритетом, которая станет главной в случае падения сервера.
  Арбитр отвечает только за выборы преемника, сам стать преемником он не может, поэтому рекомендуется отдавать под
  арбитра минимальные ресурсы. Технически можно вообще жить без арбитра, однако с ним выборы будут происходить в разы
  быстрее, соответственно время простоя будет минимизировано. Плюс есть ненулевая вероятность потерять ReplicaSet
  целиком.

## Доказательство CAP теоремы

---

В CAP теореме говорится, что в распределенной системе возможно выбрать только 2 из 3-х свойств:

- C (consistency) — согласованность. Каждое чтение даст вам самую последнюю запись.
- A (availability) — доступность. Каждый узел (не упавший) всегда успешно выполняет запросы (на чтение и запись).
- P (partition tolerance) — устойчивость к распределению. Даже если между узлами нет связи, они продолжают работать
  независимо друг от друга.

#### Доказательство:

- MongoDB обеспечивает strong consistency, потому что это система с одним Master узлом, и все записи идут по умолчанию в
  него.
- Автоматическая смена мастера, в случае отделения его от остальных узлов.
- В случае разделения сети, система прекратит принимать записи до тех пор, пока не убедится, что может безопасно
  завершить их.

> Таким образом, система может продолжать работу в случае разделения сети, но теряется availability всех узлов. Это CP
> система!

#### Дополнительно:

- Это ACID в ограниченном смысле на уровне документа.
- В случае распределенной системы — it's all about that BASE.
- В случае отсутствия разделений сети, система гарантирует, что чтение и запись будут согласованными.
- Если Master узел упадёт или потеряет связь с остальной системой, некоторые данные не будут реплицированы. Система
  выберет нового мастера, чтобы оставаться доступной для чтения и записи. (Новый мастер и старый мастер не согласованы).
- Система рассматривается как PA / EC (A), так как большинство узлов остаются CAP-available в случае разрыва. Помните,
  что в CAP MongoDB обычно рассматривается как CP. Создатель PACELC, Даниэль Дж. Абади, говорит, что существует гораздо
  больше проблем с согласованностью, чем с доступностью, поэтому PA.

## Что есть Read/Write concern?*

---

> Read concern - параметр, позволяющий управлять свойствами согласованности и изоляции данных, считываемых из наборов
> реплик и сегментов набора реплик.

> Write concern - проблема записи описывает уровень подтверждения, запрашиваемый у MongoDB для операций записи в
> автономный mongod, или в наборы реплик, или в сегментированные кластеры. В сегментированных кластерах экземпляры mongos
> будут передавать задачу записи на сегменты.

Благодаря эффективному использованию проблем записи и чтения, можно соответствующим образом регулировать уровень
согласованности и гарантий доступности, например, ожидать более строгих гарантий согласованности или ослаблять
требования к согласованности для обеспечения более высокой доступности.

## С помощью какого механизма MongoDB гарантирует персистентность? (WAL, Journal)*

---

> Чтобы обеспечить надежность в случае сбоя, MongoDB использует ведение журнала с опережением записи в файлы журнала на
> диске.

При ведении журнала WiredTiger создает одну запись журнале для каждой инициированной клиентом операции записи. Запись в
журнале включает в себя все внутренние операции записи, вызванные первоначальной записью. Например, обновление документа
в коллекции может привести к изменениям индексов; WiredTiger создает единую запись журнала, которая включает как
операцию обновления, так и связанные с ней изменения индекса.

MongoDB настраивает WiredTiger на использование буферизации в памяти для хранения записей журнала. Потоки координируют
свои действия для выделения и копирования в свою часть буфера. Все записи журнала размером до 128 КБ буферизуются.

WiredTiger синхронизирует буферизованные записи журнала с диском при выполнении любого из следующих условий:

- Для кластера replica set (основного сервера и его копий)
    - если есть операции, ожидающие записи oplog (специальная ограниченная коллекция, которая ведет непрерывный учет
      всех операций, изменяющих данные, хранящиеся в вашей базе данных):
        - прямое сканирование запросов в oplog
        - операции чтения, выполняемые как часть причинно-следственных сеансов
    - дополнительно для копий после каждого пакетного применения записей oplog
- если операция записи включает или подразумевает write concern
- каждые 100 миллионов секунд
- когда WiredTiger создает новый файл журнала. Потому что MongoDB использует файл журнала с лимитом в 100 МБ. WiredTiger
  создает новый файл журнала примерно по заполнению 100 МБ данных.

## Транзакции. Какие представляют гарантии? Как влияет на производительность?

---

В отличии от многих других NoSQL решений, MongoDB поддерживает compare-and-set. Именно поддержка CAS позволяет добавить
ACID транзакции. Если вы используете любое другое NoSQL хранилище с поддержкой CAS (например, HBase, Project Voldemort
или ZooKeeper), то описанный подход можно применить и там.

> CAS - это механизм, который гарантирует отказ в изменении объекта, если с момента последнего чтения объект был изменен
> другим клиентом. Знакомый всем пример - система контроля версий, которая откажет вам в коммите, если ваш коллега успел
> закомититься раньше.

Необходимо произвести доработки у сущности из БД, чтобы получить доступ к механизму транзакций. Нужно добавить
дополнительные поля version, updated и tx.

```
{
_id : ObjectId(".."),
version : 0,
value : {
name : "gov",
balance : 600
},
updated : null,
tx : null
}
```

По структуре updated совпадает с value, по смыслу — это измененная версия объекта, которая превратится в value, если
транзакция пройдет; tx — это объект класса ObjectId — foreign key для _id объекта, представляющий транзакцию. Объект
представляющий транзакцию так же находится под защитой CAS.

#### Гарантии MongoDB:

- атомарность на уровне документа (хотя с версии v4 атомарность расширена и на коллекции, но с рядом ограничений), что
  не вполне соответствует полной атомарности;
- окончательную, а не моментальную согласованность, что гарантирует согласованность только через определенное время, не
  гарантирует полную изоляцию и обеспечивает меньшую устойчивость в сравнении с PostgreSQL.

#### Производительность:

- **Ограничение времени выполнения транзакции**. По умолчанию MongoDB автоматически прерывает любую транзакцию с
  несколькими документами, которая выполняется более 60 секунд. Обратите внимание, что если объемы записи на сервер
  невелики, у вас есть возможность гибко настроить свои транзакции на более длительное время выполнения. Чтобы устранить
  тайм-ауты, транзакцию следует разбить на более мелкие части, которые позволяют выполнить ее в течение заданного срока.
  Вы также должны убедиться, что ваши шаблоны запросов должным образом оптимизированы с соответствующим охватом
  индексов, чтобы обеспечить быстрый доступ к данным в рамках транзакции.
- **Количество операций в транзакции**. Нет жестких ограничений на количество документов, которые могут быть прочитаны в
  рамках транзакции. В соответствии с наилучшей практикой, в рамках транзакции должно быть изменено не более 1000
  документов. Для операций, требующих изменения более 1000 документов, разработчикам следует разбить транзакцию на
  отдельные части, которые обрабатывают документы пакетно.
- **Распределенные транзакции с несколькими сегментами (шардами)**. Транзакции, которые затрагивают несколько сегментов,
  требуют больших затрат на производительность, поскольку операции координируются между несколькими участвующими узлами
  по сети.
- **Обработка исключений**. Когда транзакция прерывается, драйверу возвращается исключение, и транзакция полностью
  откатывается. Разработчикам следует добавить логику приложения, которая может перехватывать и повторять попытку
  транзакции, которая прерывается из-за временных исключений, таких как конфликт записи MVCC, временный сбой сети или
  выбор первичной реплики.
- [больше информации](https://www.mongodb.com/blog/post/performance-best-practices-transactions-and-read-write-concerns)

## Индексы. Какие бывают виды? Какие есть дополнительные атрибуты у индексов? Какой стратегии следует придерживаться?

---

> Индексы позволяют упорядочить данные по определенному полю, что впоследствии ускорит поиск. Например, если мы в своем
> приложении или задаче, как правило, выполняем поиск по полю name, то мы можем индексировать коллекцию по этому полю.

#### Типы индексов:

- **Default индекс** - Самый простой пример индекса — _id. MongoDB создает уникальный индекс для поля _id во время
  создания документа. Индекс _id не позволяет клиентам вставлять два документа с тем же значением для поля _id. Вы не
  сможете удалить поле _id из документа. Поскольку это поле проиндексировано, то идентификатор каждого документа
  хранится также в индексе, что позволяет быстро искать документы по _id.
- **Одно поле** — MongoDB поддерживает создание пользовательских возрастающих и уменьшающихся индексов на одно поле
  документа.
- **Составной индекс** — MongoDB также позволяет определить составные индексы, те индексы которые состоят из нескольких
  полей. Порядок полей в составном индексе имеет значение. Например, если составной индекс состоит
  из ```{ city: 1, email: -1 }``` индекс сортируется сначала по city и потом в пределах city по email.
- **Multikey индексы** - MongoDB использует multikey для индексации содержимого, хранящегося в массивах. В таких
  индексах допускается несколько записей в массиве указывающих на один и тот же документ.

#### Дополнительные атрибуты индексов:

- **unique** - Уникальное свойство для индекса заставляет MongoDB отклонять повторяющиеся значения для
  проиндексированного поля. Помимо уникального ограничения, уникальные индексы функционально взаимозаменяемы с другими
  индексами MongoDB.
- Разреженный индекс - По умолчанию индексы плотные, это значит, что каждому документу в индексированной коллекции
  соответствует запись в индексе, даже если в документе нет индексируемого ключа. Когда требуется уникальный индекс в
  некоторых документах поле может отсутствовать В таком случае первый элемент будет вставлен, а все последующие будут с
  ошибкой, потому что уникальный индекс со значением null уже существует. В такой ситуации плотный индекс не годиться, а
  требуется разреженный.

```
db.users.createIndex(
  { email: 1 },
  { sparse: true }
  )
 ```

- **TTL Indexes** — это специальные индексы, которые MongoDB может использовать для автоматического удаления документов
  из коллекции через определенное время. Это идеально подходит для определенных типов информации, таких как машинные
  события, данные журнала и информация о сеансе, которые должны сохраняться в базе данных в течение конечного времени.

```
// Удалить документ через 2 минуты
db.users.createIndex(
  { email: 1 },
  { expireAfterSeconds: 120 }
)
```

- **Имя индекса** — индексу также можно задать имя, для его дальнейшего удаления или поиска.

```
db.users.createIndex(
  { email: 1 },
  { name: 'catIdx' }
)
```

> Хотя индексы и позволяют повысить поиск, но с каждым индексом связаны дополнительные накладные расходы. Каждый раз
> когда в коллекцию добавляется документ, его также нужно добавить во все индексы связанные с этой коллекцией. Получается
> если над коллекцией построено 10 индексов, то при добавлении документа, нужно изменить 10 разных структур данных. И это
> относится к любой операции записи, добавления, удаления, обновления полей документа, которые проиндексированы. Для
> приложений ориентированных на чтение, затраты на индексы почти всегда оправданы. Следите за тем, чтобы индексы которые
> есть использовались, а если не используются то удаляйте их.

## Как выглядит архитектура шардированного кластера?

---

**Схема без шардирования** - есть приложение, которое через драйвер общается с mongod. mongod — это основной процесс
mongoDB, задача которого — прием запросов, их обработка и выполнение. Данные в mongod хранятся в так называемых chunks (
чанки). Каждый chunk имеет размер “chunksize”, который по умолчанию 64 MB. Физически чанки хранятся в файлах dbName.n,
где n — порядковый номер, начиная с 0. При достижении размеров 64 MB (или другого chunksize) chunk делится пополам,
получается 2 чанка поменьше — по 32 MB, эти 2 чанка начинают наполняться, пока не достигнут размера chunksize, затем
разделение происходит снова и т.д. Размер файла dbName.0 равен 64 MB, dbName.1 — 128 MB, dbName.2 — 256 и т.д. до 2Gb.
По мере роста количества и размера чанков эти файлы наполняются и когда есть первый файл — dbName.5, размер которого
равен 2 Gb, рост размера прекращается и mongoDB просто создает файлы одного и того же размера. Так же следует отметить,
что mongoDB не просто создает эти файлы по мере необходимости, а создает их заранее, чтобы при наступлении необходимости
реально записать данные в файл, не тратить время на создание файла. Поэтому при относительно небольшом размере реальных
данных, вы сможете обнаружить, что места на жестком диске занято прилично.
Данная схема применима чаще всего для локального тестирования.

**Шардированная схема**. Важное отличие шардированной схемы — у нее данные не просто записываются в чанки, которые потом делятся пополам, а попадают в них по определенному диапазону заданного поля — shard key. Сначала создается всего один чанк и диапазон значений, которые он принимает, лежит в пределах (-∞, +∞ ). Когда размер этого чанка достигает chunksize, mongos оценивает значение всех шардкеев внутри чанка и делит чанк таким образом, чтобы данные были разделены примерно поровну.

[Больше информации](https://habr.com/ru/articles/217393/)



