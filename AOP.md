## Что такое AOP?

**AOP** - Aspect Oriented Programming

**AOP** - парадигма программирования, основанная на идее разделения основного и
служебного функционала. Служебный функционал записывается в Aspect-классы.
В основе Aspect заключена сквозная логика (cross-cutting logic).

#### К сквозному функционалу относят:

- логирование;
- проверка прав (security check);
- обработка транзакций;
- обработка исключений;
- кэширование.

---

## Плюсы и минусы AOP

#### Плюсы AOP:

- сквозной функционал сосредоточен в 1-м или нескольких обособленных классах.
  Это позволяет легче его изменять.
- становится легче добавлять новые сквозные работы для нашего основного кода
  или имеющих сквозные работы для новых классов. Это достигается благодаря
  конфигурации аспектов.
- бизнес-код приложения избавляется от сквозного кода, становится меньше и чище. Работать с ним становится легче.

#### Минус AOP:

- дополнительное время на работу аспектов.

AOP frameworks:

- **Spring AOP**: предоставляет самую распространенную и необходимую функциональность AOP. Простой в использовании.
- **AspectJ**: предоставляет всю функциональность AOP. Более сложный в использовании.

---

## Начало работы с Spring AOP

Чтобы начать использовать AOP, необходимо в классе конфигурации применить
аннотацию `@EnableAspectJAutoProxy`. Данная аннотация позволяет за кулисами
использовать Spring AOP Proxy.

Затем необходимо создать класс-аспект. Он должен быть объявлен как бин, но еще включать аннотацию `@Aspect`. Данная
аннотация говорит о том, что это не просто класс, а Aspect. Поэтому к данному классу Spring будет относится по-другому.

**Aspect** - класс, отвечающий за сквозную функциональность.

---

## Типы Advice

**Advice** - метод, который находится в аспекте и содержит сквозную логику.  
Advice определяет, что и когда должно происходить. В идеальном случае он должен
быть небольшим и быстро работающим.

**Pointcut** - выражение, описывающее, где должен быть применен Advice.

`@Before("execution (public void getBook())")` - pointcut

- **Before** - выполняется до метода с основной логикой.
- **After returning** - выполняется только после нормального окончания метода с
  основной логикой.
- **After throwing** - выполняется после окончания метода с основной логикой только,
  если было выброшено исключение.
- **After/After finally** - выполняется после окончания метода с основной логикой.
- **Around** - выполняется до и после метода с основной логикой.

Spring AOP использует AspectJ Pointcut expression language. То есть определенные правила в написании выражений для
создания Pointcut.

---

## Правила написания Pointcut'ов

#### Шаблон pointcut:

`execution( modifiers-pattern? return-type-pattern declaring-type-pattern?
method-name-pattern(parameters-pattern) throws-pattern? )`

После опциональных параметров стоит знак вопроса.

Предпочтительное написание pointcut:
`@Before("execution (public void aop.UniLibrary.getBook())")`

Есть возможность использовать wildcard:
`execution(public void get*())` - соответствует методу без параметров, где бы он не находился с access modifier =
public, return type = void и именем, начинающимся на get.
Также его можно использовать вместо return type:
`execution(public * getMethod())`

`execution(* *())` - соответствует методу без параметров, где бы он не находился с любым access modifier, любым return
type и любым значением.

`execution(public void getBook(String))` - соответствует методу с параметров String, где бы он ни находился с access
modifier = public, return type = void и именем = getBook.

`execution(public void getBook(*))` - соответствует методу с любым одним параметром, где бы он ни находился с access
modifier = public, return type = void и именем = getBook.

`execution(public void getBook(..))` - соответствует методу с любым количеством любого типа параметров, где бы они не
находились с access modifier = public, return type = void, и именем = getBook.

`execution(public void getBook(aop.Book, ..))` - соответствует методу, первым параметром которого является aop.Book, а
дальше может идти 0 и больше параметров любого типа, где бы этот метод ни находился с access modifier = public, return
type = void и именем = getBook.

`execution(* *(..))` - соответствует методу с любым количеством любого типа параметров, где бы он ни находился с любым
access modifier, любым return type и любым именем.

---

## Способы объявления Pointcut

Для того, чтобы не пользоваться copy-paste, когда для нескольких advice-ов подходит один и тот же pointcut, есть
возможность объявить данный pointcut и затем использовать его несколько раз:

```java
@Pointcut("pointcut_expression")
private void pointcut_reference(){}
```

#### Использование:

```java
@Before("pointcut_reference()")
public void advice_name(){some code}
```

#### Плюсы:

- возможность использования созданного Pointcut для множества advice-ов.
- возможность быстрого изменения pointcut expression для множества advice-ов.
- возможность комбинирования pointcut-ов.

#### Комбинирование pointcut-ов:

**Комбинирование pointcut-ов** - это их объединение с помощью логических операторов && || !.

```java
@Pointcut("allGetMethodsFromUniLibrary() || allReturnMethodsFromUniLibrary()")
private void allGetOrReturnMethodsFromUniLibrary(){}
```

---